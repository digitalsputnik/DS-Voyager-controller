#Revision 3 voyager

#Andro 2018.04.17
#old ut2 script, now the main UDP communication between the outside world
#scrapped version of reinvented mesh mess

#massive while loop, polls for udp and serial received with timeouts. Needs a massive cleanup

# - missing defines for each packet identifying, hardcoded at the momement
# - missing CRC checks

# - possible cockup... Polling info in one packet, seemed like a good idea until telemetry polling with serial from LPC started causing delays. 
# - maybe remove delay and add refresh telemetry packet, controlled delay
# - Need to rework polling, LPC send periodically info, instead of CHIP sending poll request on Tx line, ie breaking animation.


VERSION=[0, 42] # 2 byte values
CLIENT_PING_DELAY = 5 # for led status, how often tries to ping, inbetween sends previous state
POLLING_DELAY = 30 # how often reads info from LPC when receives polling state.

import time
import serial
import sys
import socket
import os
import json


toHex = lambda x: " ".join("{:02X}".format(c) for c in x)

ser = serial.Serial(
        port='/dev/ttyS1',
        baudrate=750000,	  # 115200 in versions v0.00.1 - v0.02.0. 750000 from version v0.02.1 on.
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
        rtscts=True,
        timeout=0               # Rx timeout, debugging only, adds delay
)

ser.flushInput()
ser.flushOutput()

serNumberOfBytesRx = 0
serReceivedData = []

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
PORT  = 30000
HOST = ""                       #listen to all IPs
sock.bind((HOST,PORT))
sock.settimeout(0.1)			#socket timeout, tries to read serial inbetween udp timeouts.

udp_data = bytearray(5)

#color status
#short
rgbw0 = bytearray()
rgbw0[0:16] = 0xd5, 0x0a, 0x10, 0x08, 0x02, 0x00, 0x28, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0xef, 0xfe, 0x00
#long
rgbw1 = bytearray()
rgbw1[0:16] = 0xd5, 0x0a, 0x10, 0x08, 0x02, 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0xef, 0xfe, 0x00

#full length
rgbw2 = bytearray()
rgbw2[0:8] = 0xD5, 0x0A, 0x10, 0x03, 0x00, 0x00, 0x00, 0x53
for x in range(0, 330, 4):
 rgbw2[x+8:x+8+4] = 0x00, 0x00, 0x00, 0x00  #RGBW
rgbw2[340:343] = 0xEF, 0xFE, 0x00

# time delays how often some action
client_start_time = time.time() - CLIENT_PING_DELAY
start_time_polling = time.time() - POLLING_DELAY
ping_response = 0
#for timesync package, values above need reset

#dirty fix for timesync, adds 4 years since epoch, cannot set time back since boot.. not sure whats blocking.. timesync
#current_time = os.popen("date +%s%3N").readline().strip()
#if int(current_time) < 1262304000:
#	os.system("date -s 'Tue Jan  1 00:00:00 UTC 1974'")

#Reading passive(1) or active(0) mode,export PE0 pin
os.system("echo 128 > /sys/class/gpio/export")
os.system("echo in > /sys/class/gpio/gpio128/direction")

UDPResponse = {}

#poll info or states for which need to be read only once
length_read_flag = 0
lpc_read_flag = 0
chip_read_flag = 0
animation_read_flag = 0
serial_read_flag = 0
mac_read_flag = 0

while True:
	try:
		try:
			udp_data, addr = sock.recvfrom(4096)
		except KeyboardInterrupt:
			sock.close()
			ser.close()
			sys.exit()
		except:
			pass
			#print ("no udp packets")
		
		# Checks flag bytes
		if ((udp_data[0] == 0xD5) and (udp_data[1]== 0x0A) ) :
			
			#COLOR PACKET
			if (udp_data[2] == 0x10):
				ser.write(udp_data[:len(udp_data)])
				#print("Forwarding length = ", len(udp_data));
				udp_data = bytearray(5)
				
				#print(list(ser.read(len(udp_data))))

			#RESET PACKET
			#if (udp_data[2] == 0x82 and udp_data[3] == 0x10):
			
			#TIME SYNC PACKET
			if (udp_data[2] == 0x83 and udp_data[3] == 0x10):
				print ("Timesync respond")
				
				#send current time
				time_start = bytearray()
				time_start[0:4] = 0xD5, 0x0A, 0x83, 0x20
				#current_time = os.popen("date +%s%3N").readline().strip()
				current_time = str(time.time())
				time_start[4:] = bytearray(current_time, "ascii")
				print (time.time())
				#print (list(time_start))
				sock.sendto(time_start, addr)
				udp_data = bytearray(5)
			
			#DUMMY TIME SYNC PACKET - testing timedelays.
			if (udp_data[2] == 0x84 and udp_data[3] == 0x10):
				#send current time
				time_start = bytearray()
				time_start[0:4] = 0xD5, 0x0A, 0x84, 0x20
				#current_time = os.popen("date +%s%3N").readline().strip()
				current_time = str(time.time())
				time_start[4:] = bytearray(current_time, "ascii")
				#print (list(time_start))
				sock.sendto(time_start, addr)
				udp_data = bytearray(5)
			
			#AP PACKET - start _M access point
			if (udp_data[2] == 0x81 and udp_data[3] == 0x10):
				print ("start AP _M")
				
				AP_start_reply = bytearray()
				AP_start_reply[0:7] = 0xD5, 0x0A, 0x81, 0x20, 0xEF, 0xFE, 0x00
				sock.sendto(AP_start_reply, addr)
				udp_data = bytearray(5)
				
				print ("start |AP")
				
				#flash led when activating master _M
				for x in range(0, 330, 4):
					rgbw2[x+8:x+8+4] = 0x80, 0x80, 0x80, 0x80  #RGBW					
				ser.write(rgbw2)
				time.sleep(0.1)

				for x in range(0, 330, 4):
					rgbw2[x+8:x+8+4] = 0x00, 0x00, 0x00, 0x00  #RGBW					
				ser.write(rgbw2)
				
				
				#Stops client mode
				os.system("ls /var/lib/connman/*| grep -v settings| xargs rm -rf")

				#Stop autoconnect
				os.system("ps ax | grep autoconnect | awk -F ' ' '{print $1}' | xargs kill -9")

				#Starts AP _M
				os.system("sh /mnt/data/netchanger.sh 1 &")
				
				time.sleep(6)
			
			#POLL PACKET FROM UDP DEVICE OUTSIDE
			if (udp_data[2] == 0x80 and udp_data[3] == 0x10):

				if (time.time() - start_time_polling > POLLING_DELAY ):
					start_time_polling=time.time()
					print ("POLL PACKET")
						
						
					### IP
					#sets client wlan0 by default
					if os.popen("ip addr | egrep -i 'inet.+wlan0' | awk -F[\ /] '{print $6}'").readline().strip() != "":
						#IP_reply = os.popen("ip addr | egrep -i 'inet.+wlan0' | awk -F[\ /] '{print $6}'").readline().strip()
						UDPResponse["IP"] = list(socket.inet_aton(os.popen("ip addr | egrep -i 'inet.+wlan0' | awk -F[\ /] '{print $6}'").readline().strip()))
					# if no wlan0 IP. sets AP ip
					else:
						UDPResponse["IP"] = list(socket.inet_aton(os.popen("ip addr | egrep -i 'inet.+wlan1' | awk -F[\ /] '{print $6}'").readline().strip()))
					
					#if master with 172.20.1.1, overrides
					if os.popen("ip addr | egrep -i 'inet.+wlan1' | awk -F[\ /] '{print $6}'").readline().strip() == "172.20.1.1":
						UDPResponse["IP"] = list(socket.inet_aton(os.popen("ip addr | egrep -i 'inet.+wlan1' | awk -F[\ /] '{print $6}'").readline().strip()))

					### NUMBER OF LEDS
					if length_read_flag == 0:
						ser.write([0xd5, 0x0a, 0x50, 0x03, 0xef, 0xfe, 0x00])
						time.sleep(0.05)
						led_amount = ser.read(10)
						if (len(led_amount) > 5):
							if (led_amount[0] == 0xD5 and led_amount[1] == 0x0A and led_amount[2] == 0x50 and led_amount[3] == 0x03):
								UDPResponse["length"] = led_amount[4]
								length_read_flag = 1
								
					### BATTERY LEVEL
					ser.write([0xd5, 0x0a, 0x20, 0x04, 0xef, 0xfe, 0x00])
					time.sleep(0.1)
					battery_lvl = ser.read(10)
					if (len(battery_lvl) > 5):
						if (battery_lvl[0] == 0xD5 and battery_lvl[1] == 0x0A and battery_lvl[2] == 0x20 and battery_lvl[3] == 0x04):
							UDPResponse["battery_level"] = battery_lvl[4]
					
					
					### TEMPERATURE	###
					#BQ - In Kelvin
					ser.write([0xd5, 0x0a, 0x20, 0x02, 0x20, 0x08, 0x00, 0xef, 0xfe, 0x00])
					time.sleep(0.1)
					sbs = ser.read(15)
					if (len(sbs) > 5):
						if (sbs[0] == 0xD5 and sbs[1] == 0x0A and sbs[2] == 0x20 and sbs[3] == 0x02 and sbs[4] == 0x21 and sbs[5] == 0x08):
							kelvin = float(int.from_bytes(sbs[8:10], byteorder='little'))
							celsius = kelvin/10 - 273.15
							UDPResponse["BQ_temp"] = int(str(celsius)[:2]), int(str(celsius)[3:4])

					#CHIP
					chip_temp = os.popen("sh /mnt/data/chip_temp.sh").readline().strip()
					UDPResponse["CHIP_temp"] = int(chip_temp)
					
					### CHARGING
					ser.write([0xd5, 0x0a, 0x20, 0x02, 0x20, 0x0A, 0x00, 0xef, 0xfe, 0x00])
					time.sleep(0.1)
					sbs = ser.read(15)
					if (len(sbs) > 5):
						if (sbs[0] == 0xD5 and sbs[1] == 0x0A and sbs[2] == 0x20 and sbs[3] == 0x02 and sbs[4] == 0x21 and sbs[5] == 0x0A):
							UDPResponse["charging_status"] = list(sbs[8:10])
					
					### VERSIONS ###
					#LPC
					if lpc_read_flag == 0:
						ser.write([0xd5, 0x0a, 0x30, 0x01, 0x20, 0xef, 0xfe, 0x00])
						time.sleep(0.1)
						lpc_version = ser.read(10)
						if (len(lpc_version) > 5):
							if (lpc_version[0] == 0xD5 and lpc_version[1] == 0x0A and lpc_version[2] == 0x30 and lpc_version[3] == 0x01 and lpc_version[4] == 0x21):
								UDPResponse["LPC_version"] = list(lpc_version[5:7])
								lpc_read_flag = 1
						
					#CHIP
					if chip_read_flag == 0: 
						UDPResponse["CHIP_version"] = VERSION
						chip_read_flag = 1
						
					#Animation 
					if animation_read_flag == 0:
						if os.path.isfile("/mnt/data/animation/version"):
							animation_ver_read = os.popen("cat /mnt/data/animation/version").readline().strip().split('.')
							animation_ver_read  = [int(i) for i in animation_ver_read ]
							UDPResponse["animation_version"] = animation_ver_read
							animation_read_flag = 1
						else:
							UDPResponse["animation_version"] = [0,0]
							animation_read_flag = 1
						
					#6last mac
					if mac_read_flag == 0:
						UDPResponse["MAC_last6"] = os.popen("ip addr show wlan1 | sed -n 2p | tr -d : | cut -d ' ' -f 6 | cut -c 7-").readline().strip()
						mac_read_flag = 1
					
					#Passive or Active mode
					UDPResponse["passive_active_mode"] = int(os.popen("cat /sys/class/gpio/gpio128/value").readline().strip())
					
					#! Need to add master _M !#
					#Serial name / SSID
					if serial_read_flag == 0:
						UDPResponse["serial_name"] = os.popen("cat /mnt/data/serial.txt").readline().strip()
						serial_read_flag = 1
						
					#SEND POLL PACKET RESPONSE
					#Generate JSON string
					UDPResponseJSON = json.dumps(UDPResponse)
					#Send generated JSON
					sock.sendto(UDPResponseJSON.encode(), addr)
					
					#sock.sendto(poll_reply, addr)
					#print("POLL SENT")
					#print (list(poll_reply))
					#print (len(poll_reply))
					
				else:
					#print ("send poll, with out rereading")
					sock.sendto(UDPResponseJSON.encode(), addr)
					#sock.sendto(poll_reply, addr)
					
				serReceivedData = []
				serNumberOfBytesRx = 0
				ser.flushInput()
				ser.flushOutput()
				udp_data = bytearray(5)
		#else:
		#	print('wrong flag')
				
		if(ser.in_waiting != 0):
			serReceivedData = ser.read(7)
			
			#print ("serial received")
			#print (list(serReceivedData))


			### SIDE BUTTON ###
			
			if (serReceivedData[0] == 0xD5  and serReceivedData[1]== 0x0A and serReceivedData[2] == 0x50 and serReceivedData[3] == 0x04 and serReceivedData[4] == 0x01 and
				os.popen("ip addr | egrep -i 'inet.+wlan1' | awk -F[\ /] '{print $6}'").readline().strip() != "172.20.1.1" ):
				print (int(serReceivedData[5]))
				if int(serReceivedData[5]) > 15:
											
					for x in range(0, 330, 4):
						rgbw2[x+8:x+8+4] = 0x00, 0x00, 0x00, 0x00  #RGBW
					rgbw2[168:172] = 0x30, 0x30, 0xFF, 0x00
					#rgbw2[172:176] = 0x00, 0x00, 0xFF, 0x00					
					rgbw2[336:340] = 0x30, 0x30, 0xFF, 0x00
					#rgbw2[330:334] = 0x00, 0x00, 0xFF, 0x00
					ser.write(rgbw2)
					time.sleep(0.1)
					ser.write(rgbw2)
					time.sleep(0.1)
					ser.write(rgbw2)				
					time.sleep(0.1)
					
					
					for x in range(0, 330, 4):
						rgbw2[x+8:x+8+4] = 0x00, 0x00, 0x00, 0x00  #RGBW					
					ser.write(rgbw2)
					
					#Stops client mode
					os.system("ls /var/lib/connman/*| grep -v settings| xargs rm -rf")

					#Stop autoconnect
					os.system("ps ax | grep autoconnect | awk -F ' ' '{print $1}' | xargs kill -9")

					#Starts AP _M
					os.system("sh /mnt/data/netchanger.sh 1 &")
										
					counter = 0
					while counter < 24:
						time.sleep(0.25)
						rgbw0[9:12] = rgbw1[9:12] = 0x00, 0x00, 0xFF
						ser.write(rgbw0[:len(rgbw0)])
						time.sleep(0.05)
						ser.write(rgbw1[:len(rgbw1)])
						counter += 1
											
			###TOP BATTERY BUTTON###
			# Checks flag bytes
			if ((serReceivedData[0] == 0xD5)  and (serReceivedData[1]== 0x0A) and (serReceivedData[2]== 0x50) and (serReceivedData[3]== 0x05)) :
				### INSTANT PRESS ###
				if (serReceivedData[2] == 0x50 and serReceivedData[3] == 0x05 and serReceivedData[4] == 0x01 ):
	
					print ("instant press")
					
					#print (list(rgbw0))
					print (list(serReceivedData))

					#Suspend ut2 script - stops receiving udp packets
					#os.popen("ps ax | grep ut2 | awk -F ' ' '{print $1}' | xargs kill -SIGSTOP")
					
					# Checks if wlan1 has IP of 172.20.1.1, SSID ..._M and UP
					if (os.popen("ip addr | egrep -i 'inet.+wlan1' | awk -F[\ /] '{print $6}'").readline().strip() == "172.20.1.1" and 
						os.popen("grep ssid='\<DS026.........._M\>' /etc/hostapd.conf").readline().strip() != '' and
						os.popen("ip addr show dev wlan1 | awk 'NR==1{print $9}'").readline().strip() == 'UP' 
						):
						print ("AP ok")
						rgbw0[9:12] = rgbw1[9:12] = 0x00, 0x00, 0xFF
						print (list(rgbw0))
						print (list(rgbw1))
						ser.write(rgbw0[:len(rgbw0)])
						time.sleep(0.05)
						ser.write(rgbw1[:len(rgbw1)])
							 
					# checks if a client, Wlan0 IP, tries to ping host. pings again in 5s
					elif (os.popen("ip addr | egrep -i 'inet.+wlan0' | awk -F[\ /] '{print $6}'").readline().strip() != ''):
						if (time.time() - client_start_time > CLIENT_PING_DELAY ):
							if (os.system("ping -c 1 -W 1 -I wlan0 $(ip route | awk 'NR==1{print $3}') > /dev/null") == 0 ):
								print ("client, reset")
								client_start_time=time.time()
								ping_response = 1
								rgbw0[9:12] = rgbw1[9:12] = 0x00, 0xFF, 0x00
								ser.write(rgbw0[:len(rgbw0)])
								time.sleep(0.05)
								ser.write(rgbw1[:len(rgbw1)])
							else:
								print ("no ping response")
								ping_response = 0
								rgbw0[9:12] = rgbw1[9:12] = 0xFF, 0x70, 0x00
								ser.write(rgbw0[:len(rgbw0)])
								time.sleep(0.05)
								ser.write(rgbw1[:len(rgbw1)])
								
						elif( ping_response == 1):
							print ("client1")
							rgbw0[9:12] = rgbw1[9:12] = 0x00, 0xFF, 0x00
							ser.write(rgbw0[:len(rgbw0)])
							time.sleep(0.05)
							ser.write(rgbw1[:len(rgbw1)])
					
					# Not client or master client _M
					else:
						print ("None")
						rgbw0[9:12] = rgbw1[9:12] = 0xFF, 0x70, 0x00
						ser.write(rgbw0[:len(rgbw0)])
						time.sleep(0.05)
						ser.write(rgbw1[:len(rgbw1)])
						
			serReceivedData = []
			serNumberOfBytesRx = 0
			ser.flushInput()
			ser.flushOutput()
		#udp_data = bytearray(5)

	except KeyboardInterrupt:
		sock.close()
		ser.close()
		sys.exit()
	except:
		pass
		#print ("send fail")

			
sock.close()
ser.close()
exit()
